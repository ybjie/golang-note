# common
- iota是一个特殊的常量，它是可以被编译器修改的常量，它在const关键字出现的时候被重置为0，const内部每新增一行则iota计数+1
- go的++ --操作只能做为表达式使用，不能做为赋值语句使用
- &是变量在内存中的地址， *则是要取得这个内存地址上存储的是什么
- 没有类，有struct的概念，自定义数据结构

# 代码结构
- go的if 后的bool表达式 是没有括号的
- go的{是不可以独占一行的
- go的switch是自带break的，如果希望继续执行可以使用fallthrough
- select是类似于通信的switch，循环检测所有条件直到又满足的，否则将会阻塞

# 循环
- for 直接顶替了 for while 甚至foreach
- break continue goto基本类似

# 函数
- go的函数是可以有多个返回值的
- 函数名称和参数列表共同构成了函数签名
- 如果有返回值则返回类型必须一致

# 数组与切片
- go的数组需要预订长度，以及数据类型，且所有元素类型必须一致，长度一旦确定不可变
- 切片则不需要预订长度，随时可扩充
- 切片类型、字典、通道、函数都是引用类型
- 数组、结构体、基础数据类型是值类型
- 

# 赋值
- 短变量声明
- 重复变量声明
- 变量生小范围&优先级
- 一个不包含任何内容的{}不仅可以代表一个空代码块，还可以代表示不包含任何内容的数据结构

# 类型转换
- 对于整数类型值和整数常量之间的类型转换原则上只要源值在目标类型的表示范围内，就可以进行转换
- 原则上直接把一个整形转换为string是可以的，但是要求源值必须是可以代表一个有效unicode代码点的，否则转换结果将会是"�"，这玩意儿是unicode中专门用来表示那些未知的、不被认可的、无法展示的字符
- 一个值在从string类型向[]byte类型转换代表着以utf-8编码的字符串会被拆分成单独的、零散的字节
- 别名类型 使用type进行定义，更多场合是为了更易于理解的类型，其实是同一种类型，只是名字不同
- 潜在类型则是与类型再定义一起的
- 潜在类型相同的不同类型之间是可以互相转换的，但集合类型之间是不可以的
- 即使两个类型的潜在类型相同也无法进行判等或比较，变量也不能直接进行赋值
