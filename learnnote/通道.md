# 关于通道的基本知识
- 通道是go自带的、唯一可以满足并发安全的数据类型
- 声明并初始化一个通道的时候需要用到内置make函数
- 一个通道简单类似一个先进先出的队列、通道中的数据都是严格地按照发送顺序排列的

# 关于通道的基本操作
- 对于同一个通道，发送操作之间是互斥的、接收操作之间也是互斥的
- 发送操作、接收操作对元素的处理都是不可分割的
- 发送操作在被完全接收之前是被阻塞的、接收操作也是如此
- 关于发送和接收操作的都是副本文件，也就是说，发送操作是复制了一个元素副本接着放到通道中、接收操作则是复制一个通道中元素的副本出去接着从通道中删除这个元素
- 一旦一个通道被关闭了，我们可能会从通道接收到一个该类型的零值
试图对一个已经关闭的通道进行发送操作会产生panic、另外试图关闭一个已经关闭了的通道也会引发panic，通常来讲我们一定不要让接收方来关闭通道，应该让发送方操作

# 高级操作
- 如果对于select加入了默认分支，那么无论涉及的通道表达式操作是否有阻塞select都不会被阻塞
- 如果没有默认分支，如果涉及的通道操作都被阻塞了那么select就也会被阻塞，直到至少有一个case表达式满足
- 涉及上文我们可能从一个关闭的通道获取一个类型零值，通常我们要辅助使用第二个表达式来判断是否关闭，如果关闭则要及时屏蔽掉对应的分支
- select语句智能对各个case表达式求值一次，所以如果我们需要定时货连续操作通道的话可能需要与for一起联合使用，但要注意，简单的在select分支中使用break只会结束当前select并不会结束for，所以这里错误的用法可能会引起死循环

# select分支选择的原则有哪些
- 每一个case表达式都要包含一个通道发送或者接收操作，同时也可能包含其它表达式，这些表达式总会被按照从左到右的顺序被求值
- select包含的候选分支涉及的表达式都会在该语句被执行的时候先被求值，顺序就是代码编写的顺序从上到下
- 每一个case如果涉及的通道操作被阻塞我们就认为这个case的求值是不成功的
- 如果多个case同时满足要求，就会使用一种伪随机的算法选择其中的一个执行，需要注意的是即使是select被唤醒的情况下也是如此
- 每个select最多只能有一个默认候选分支
- select的每次执行，case表达式求值和分支执行都是独立的
