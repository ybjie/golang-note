# 竞态条件
- 一旦数据被多个线程共享，那么就可能产生争用和冲突的情况，这就叫做竞态条件

# 临界区
- 只要一段代码需要实现对共享资源的串行访问，就可以被视为临界区

# 同步工具
- 同步的作用有两个，一是避免多个线程再同一时刻操作统一数据块，二是协调多个线程以避免他们在同一时刻执行同一代码块
- 我们所说的同步其实就是控制多个线程对共享资源的访问
- 施加保护的手段就是使用实现了某种同步机制的工具，就是同步工具
- go语言中最常用的同步工具就是互斥量简称mutex

# 使用互斥锁的注意事项
- 不要重复锁定
- 不要忘记解锁，必要时候使用defer
- 不要重复解锁，解锁前必须要先加锁
- 不要在多个函数之间直接传递互斥锁，这是因为会产生它的副本，可能会引起歧义，并导致互斥操作的失效

# 读写锁的使用规则
- 写锁已被锁定的情况下再次尝试锁定会阻塞当前goroutine
- 写锁已被锁定的情况下尝试读锁也会被阻塞
- 读锁已被锁定的情况下尝试写锁也会被锁定
- 读锁已被锁定的情况下尝试读锁没有问题

# 条件变量
- 条件变量是基于互斥锁的，没有互斥锁条件变量不能发挥作用
- 条件变量并不是用来保护临界区与共享资源的，它是用来协调那些想访问共享资源的线程的，当共享资源的状态发生变化的时候，它可以通知被互斥变量阻塞的行线程
- wait方法做了什么
  - 把调用它的goroutine加入到当前条件变量的通知队列中
  - 解锁当前条件变量基于的那个互斥锁
  - 让当前goroutine处于等待状态，当通知到来的时候再决定是否唤醒它
  - 如果决定唤醒，会首先再次锁定当前条件变量基于的那个互斥锁
- signal方法只会唤醒一个，broadcast方法则会唤醒所有,这两个方法不需要受到互斥锁的保护，我们也最好不要再解锁互斥锁之前调用
